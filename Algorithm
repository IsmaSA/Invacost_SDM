###############################################################################
#################                 ALGORITHM             ######################
###############################################################################

gc()
setwd("C:/Users/isma-/OneDrive/Escritorio/SDM_Invacost")

### GAMs
library(mgcv)
library(caret)
library(pROC)
set.seed(123)

sp <- read_xlsx("Species_ID.xlsx")
env <- read_xlsx("ID_predictors.xlsx")
background <- read_xlsx("pseudoabsences.xlsx")
all_cells <- read.csv2("All_cells_values.csv")


spn <- unique(sp$species)
spn<- spn[1:3]
n <- spn[1]

#We will need this to proyect the results
world_extent <- extent(-180, 179, -56, 84)
prediction_raster <- raster(world_extent, resolution = 0.08333333)

#To apply the mask
bio <- raster::getData('worldclim', var='bio', res=5)

#AUC
AUC_df <- data.frame(species = character(), auc = numeric(), stringsAsFactors = FALSE)
gam_models <- list()


for (n in spn) {
  sp1<- sp[sp$species == n,]
  sp$presence <- 1
  
  if (nrow(sp1) < 10) {
    next  
  }
  
  #Combine data
  data <- bind_rows(sp1, background) # sp + background
  SDM_data<- right_join(env,data, by="cell.id") # + env data
  #SDM_data$presence <- ifelse(is.na(SDM_data$presence), 0, SDM_data$presence)
  
 #Split in train and evalutaion 
  indices <- sample(nrow(SDM_data))
  n_train <- round(0.7 * nrow(SDM_data))

  train_data <- SDM_data[indices[1:n_train], ]
  val_data <- SDM_data[indices[(n_train+1):nrow(SDM_data)], ]
  
  
  #Start modelling
  response<- train_data$presence
  predictors <- c("bioclim.bio2", "bioclim.bio1","bioclim.bio10", "bioclim.bio4", "Elevation", "Rugosity", "Slope")
   formula <- as.formula(paste("presence ~", paste0("s(", predictors, ", k = 5)", collapse = "+")))
  
  GAM_model <- gam(formula, data = train_data, family = binomial, select = TRUE)
  
  
  #Check concurvity:
  concurvity_threshold <- 0.8
  worst_concurvity <- 1 
  predictor_to_remove <- NULL  
  
  while (worst_concurvity >= concurvity_threshold) {
    predictors <- attr(terms(GAM_model), "term.labels")
    worst_concurvity <- 0
    
    for (predictor in predictors) {
      
      formula_temp <- update(formula, . ~ . - eval(parse(text = predictor)))
      GAM_model_temp <- gam(formula_temp, data = train_data, family = binomial, select = TRUE)
      
      resampled_data <- train_data
      resampled_data$presence <- sample(resampled_data$presence)
      
      # Fit the GAM model with the resampled data
      GAM_model_resampled <- gam(formula_temp, data = resampled_data, family = binomial, select = TRUE)
      
    
      concurvity_value <- concurvity(GAM_model_temp) - concurvity(GAM_model_resampled)
      worst_concurvity <- max(worst_concurvity, concurvity_value)
      
      if (worst_concurvity >= concurvity_threshold) {
        predictor_to_remove <- predictor
      }
    }
    
    if (!is.null(predictor_to_remove)) {
      
      formula <- update(formula, . ~ . - eval(parse(text = predictor_to_remove)))
      GAM_model <- gam(formula, data = train_data, family = binomial, select = TRUE)
    }
  }
  
  env_subset <- env[, predictors]
  
  #validation the model
  pred_probs <- predict(GAM_model, newdata = val_data, type = "response")
  auc<- roc(val_data$presence, pred_probs)$auc
  AUC_df <- rbind(AUC_df, data.frame(species = n, auc = auc))
  
  #combine the models
  gam_models[[n]] <- GAM_model
  combined_model <- combine(gam_models)
  
  
  #-----------------------
  # Predicción sobre el mundo
  prediction <- predict(combined_model, newdata = env_subset, type = "response", na.action = "na.pass")
  prediction_matrix <- matrix(prediction, nrow = nrow(prediction_raster), ncol = ncol(prediction_raster), byrow = TRUE)
  prediction_raster <- raster(prediction_matrix, xmn = extent(prediction_raster)[1], xmx = extent(prediction_raster)[2],
                              ymn = extent(prediction_raster)[3], ymx = extent(prediction_raster)[4],
                              crs = projection(prediction_raster))
  
  # Máscara
  bioclim_variable <- bio[[3]]
  water_mask <- bioclim_variable > 0  
  water_mask <- crop(water_mask, grid_extent) 
  masked_prediction <- mask(prediction_raster, water_mask)
  
  # Plot
  cl <- colorRampPalette(c('gray90','gray75','gray65','gray50','gray30'))
  breaks <- seq(0, 1, by = 0.2)
  
  pdf_file <- paste0("plot_", n, ".pdf")
  
  # Open a PDF device with the unique file name
  pdf(pdf_file)
  
  levelplot(masked_prediction, col.regions = cl, margin = FALSE,
            at = breaks,
            panel = function(...) {
              panel.levelplot(...)
              map("world", add = TRUE, col = "green", fill = FALSE, lwd = 0.5)
            })
  dev.off()
  cat("LOL", ":/n")
  
}
  
  



color_palette <- viridis(5)

# Convert raster to a data frame
df <- as.data.frame(masked_prediction, xy = TRUE)
ggplot() +
  geom_tile(data = df, aes(x = x, y = y, fill = layer), width = 1, height = 1) +
  scale_fill_gradientn(colors = color_palette) +
  theme_void() +
  borders("world", colour = "lightgray", fill = NA)








